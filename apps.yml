- name: knoxauth
  actioncreators_prepend: |
    // import { checkHttpStatus, parseJSON } from './utils'
    import {
      push, go, replace
    } from 'react-router-redux'
    
    import * as _btoa from 'btoa'
    
    const btoa = (process.env.BUILD_FLAG_IS_CLIENT === 'true') ? window.btoa : _btoa

    const api_url = (process.env.BUILD_FLAG_IS_CLIENT === 'true') ? 'frontend' : 'backend'

  actions:
    - name: authLoginUserRequest
    - name: authLoginUser
      args: email,password,redirect = '/'
      thunk:
        args: axios,cookie
        thunk: |
          return axios
            .post(`${api_url}/v1/accounts/login/`, {
              method: 'post',
              headers: {
                  'Accept': 'application/json',
                  'Content-Type': 'application/json',
                  'Authorization': `Basic ${auth}`
              }
          })
          .then(checkHttpStatus)
          .then(parseJSON)
          .then((response) => {
              cookies.set('knoxToken', response.token)
              dispatch(authLoginUserSuccess(response.user));
          })
          .then(() => true)
          .catch((error) => {
              if (error && typeof error.response !== 'undefined' && error.response.status === 401) {
                  // Invalid authentication credentials
                  return error.response.json().then((data) => {
                      dispatch(authLoginUserFailureReport(401, data.non_field_errors[0]));
                  });
              } else if (error && typeof error.response !== 'undefined' && error.response.status >= 500) {
                  // Server side error
                  dispatch(authLoginUserFailureReport(500, 'A server error occurred while sending your data!'));
              } else {
                  // Most likely connection issues
                  dispatch(authLoginUserFailureReport('Connection Error', 'An error occurred while sending your data!'));
              }

              return Promise.resolve(true); // TODO: we need a promise here because of the tests, find a better way
            })
    - name: authLogoutAndRedirect
      thunk:
        args: axios,cookie
        thunk: |
          return axios
            .get(`https://jsonplaceholder.typicode.com/Todos/${id}`)
            .then(({ data }) => { for (let todo in data) dispatch(addTodo(todo)) })
            .then(() => true);
    - name: authLoginUserSuccess
      args: payload
    - name: authLoginUserFailure
      args: status,statusText
    - name: authLoginUserFailureReport
      args: status,statusText
      thunk:
        args: cookies
        thunk: |
          cookies.remove('knoxToken')
          dispatch(authLoginUserFailure(status, statusText))
          return Promise.resolve(true);
    - name: authLogoutUser
    - name: authLogoutUserDo
      thunk:
        args: cookies
        thunk: |
          cookies.remove('knoxToken')
          dispatch(authLogout())
          return Promise.resolve(true)
    - name: authLogoutUserAndRedirect
      thunk:
        args: cookies
        thunk: |
          dispatch(authLogoutUserDo())
          dispatch(push('/login'))
          return Promise.resolve(true)

  reducers_prepend: |
    const initialState = {
        userName: null,
        isAuthenticated: false,
        isAuthenticating: false,
        statusText: null
    };
  reducers:
    - name: authReducer
      default: initialState
      actions:
        - name: authLoginUserRequest
          reducer: |
            return Object.assign({}, state, {
                isAuthenticating: true,
                statusText: null
            });
        - name: authLoginUserSuccess
          reducer: |
            return Object.assign({}, state, {
                isAuthenticating: false,
                isAuthenticated: true,
                userName: action.payload.email,
                statusText: 'You have been successfully logged in.'
            });

        - name: authLoginUserFailure
          reducer: |
            return Object.assign({}, state, {
                isAuthenticating: false,
                isAuthenticated: false,
                userName: null,
                statusText: `Authentication Error: ${action.payload.status} - ${action.payload.statusText}`
            });
        - name: authLogoutUser
          reducer: |
            return Object.assign({}, state, {
                isAuthenticated: false,
                userName: null,
                statusText: 'You have been successfully logged out.'
            });
  selectors:
  components:    
    - name: LoginRoute
      actions:
      selectors:
      prepend: |
        import React from 'react';
        import PropTypes, { string } from 'prop-types';
        import { compose } from 'redux';
        import { connect } from 'react-redux';
        import { withJob } from 'react-jobs';
        import Helmet from 'react-helmet';
        import LoginForm from './LoginForm';
      component_content: |

        class LoginRoute extends React.Component {

          render() {
            return (
              <div>
                <h3>Login</h3><LoginForm />
              </div>
            );
          }
        }

        // export default connect(mapStateToProps, mapActionsToProps)(LoginRoute);

        export default LoginRoute
    - name: LoginFormRedux
      actions: authLoginUser
      selectors: 
      prepend: |
        import React from 'react'
        import { Field, reduxForm } from 'redux-form'
        import { Button, Form, FormGroup, Label, Input, FormText, Col } from 'reactstrap';

      component_content: |

        const col_wrap = (col_opts, input) => (
          <Col {...col_opts}>
            {input}
          </Col>
        )


        const ChildField = ({children, input, label, meta, help, input_position=null label_opts={}, col_opts=null, ...rest}) => (
          <FormGroup check={rest.check} row={rest.row} disabled={rest.disabled} className={rest.className}>
            <Label key="label" for={"id_"+input.name} {...label_opts}>
              {input_position=="left" ? children({input, meta, ...rest}) : ""}
              {label}
              {input_position=="right" ? children({input, meta, ...rest}) : ""}
            </Label>
            {!input_position ? (col_opts ? col_wrap(col_opts, children({input, meta, ...rest})) : children({input, meta, ...rest})) : ""}
            {meta.touched && meta.error && <FormFeedback>{meta.error}</FormFeedback>}
            {help && <FormText color="muted">{help}</FormText>}
          </FormGroup>
        )

        const GridCheckField = ({col_opts={sm:2}, label_opts={check:true}, ...rest}) => {
          return ChildField({col_opts, label_opts, ...rest})
        }
        

        const LoginForm = props => {
          const { handleSubmit, pristine, reset, submitting } = props
          return (
            <Form onSubmit={handleSubmit}>
                  <Field component={ChildField} name="firstName"
                    placeholder="First Name" label="First Name"
                    className="" help="help" disabled
                  >
                    {({input, meta: { touched, error }, ...rest }) => (
                      <Input key="input" type="text" id={"id_"+input.name} {...input} placeholder={rest.placeholder} valid={error ? false: true}/>
                    )}
                  </Field>
              <div>mi
                <button type="submit" disabled={pristine || submitting}>
                  Submit
                </button>
                <button type="button" disabled={pristine || submitting} onClick={reset}>
                  Clear Values
                </button>
              </div>
            </Form>
          )
        }

        export default reduxForm({
          form: 'LoginForm' // a unique identifier for this form
        })(LoginForm)el_opts={check:true}, ...rest}) => {
          return ChildField({col_opts, label_opts, ...rest})
        }
        

        const LoginForm = props => {
          const { handleSubmit, pristine, reset, submitting } = props
          return (
            <Form onSubmit={handleSubmit}>
                  <Field component={ChildField} name="firstName"
                    placeholder="First Name" label="First Name"
                    className="" help="help" disabled
                  >
                    {({input, meta: { touched, error }, ...rest }) => (
                      <Input key="input" type="text" id={"id_"+input.name} {...input} placeholder={rest.placeholder} valid={error ? false: true}/>
                    )}
                  </Field>
              <div>mi
                <button type="submit" disabled={pristine || submitting}>
                  Submit
                </button>
                <button type="button" disabled={pristine || submitting} onClick={reset}>
                  Clear Values
                </button>
              </div>
            </Form>
          )
        }

        export default reduxForm({
          form: 'LoginForm' // a unique identifier for this form
        })(LoginForm)
    - name: LoginForm
      prepend: |
        import Formsy from 'formsy-react';
        import React from 'react';
        import MyInput from './MyInput';
      component_content: |
        export default class LoginForm extends React.Component {
          constructor(props) {
            super(props);
            this.disableButton = this.disableButton.bind(this);
            this.enableButton = this.enableButton.bind(this);
            this.state = { canSubmit: false };
          }

          disableButton() {
            this.setState({ canSubmit: false });
          }

          enableButton() {
            this.setState({ canSubmit: true });
          }

          submit(model) {
            fetch('http://example.com/', {
              method: 'post',
              body: JSON.stringify(model)
            });
          }

          render() {
            return (
              <Formsy onValidSubmit={this.submit} onValid={this.enableButton} onInvalid={this.disableButton}>
                <MyInput name="email"
                  placeholder="email@example.com" label="Email"
                  className="" help="help"
                  validations="isEmail"
                  validationError="This is not a valid email"
                  required
                />
                <button type="submit" disabled={!this.state.canSubmit}>Submit</button>
              </Formsy>
            );
          }
        }
    - name: MyInput
      component_content: |
        import { withFormsy } from 'formsy-react';
        import React from 'react';
        import { Button, Form, FormGroup, Label, Input, FormText, FormFeedback, Col } from 'reactstrap';

        const col_wrap = (col_opts, input) => (
          <Col {...col_opts}>
            {input}
          </Col>
        )


        const ChildField = ({inputWidget, label, help, input_position=null, label_opts={}, col_opts=null, ...rest}) => (
          <FormGroup check={rest.check} row={rest.row} disabled={rest.disabled} className={rest.className}>
            <Label key="label" for={"id_"+rest.name} {...label_opts}>
              {input_position=="left" ? inputWidget(rest) : ""}
              {label}
              {input_position=="right" ? inputWidget(rest) : ""}
            </Label>
            {!input_position ? (col_opts ? col_wrap(col_opts, inputWidget(rest)) : inputWidget(rest)) : ""}
            {rest.errorMessage && <FormFeedback>{rest.errorMessage}</FormFeedback>}
            {help && <FormText color="muted">{help}</FormText>}
          </FormGroup>
        )

        const GridCheckField = ({col_opts={sm:2}, label_opts={check:true}, ...rest}) => {
          return ChildField({col_opts, label_opts, ...rest})
        }
        
        const InputWidget = ({errorMessage, getErrorMessage, getErrorMessages, getValue, hasValue, isFormDisabled, isValid, isPristine, isFormSubmitted, isRequired, isValidValue, resetValue, setValidations, setValue, showRequired, showError, validations, validationError, validationErrors, ...input}) => (
          <Input key="input" type="text" id={"id_"+input.name} {...input} placeholder={input.placeholder} valid={errorMessage ? false: true}/>
        )

        class MyInput extends React.Component {
          constructor(props) {
            super(props);
            this.changeValue = this.changeValue.bind(this);
          }

          getWidgetValue(event) {
            return event.currentTarget.value;
          }

          changeValue(event) {
            // setValue() will set the value of the component, which in
            // turn will validate it and the rest of the form
            // Important: Don't skip this step. This pattern is required
            // for Formsy to work.
            this.props.setValue(this.getWidgetValue(event));
          }

          render() {
            // An error message is returned only if the component is invalid
            const errorMessage = this.props.getErrorMessage();
            
            const {required, ...rest} = this.props;

            return ChildField({inputWidget: InputWidget, onChange: this.changeValue, errorMessage: errorMessage, ...rest});

          }
        }

        export default withFormsy(MyInput);
