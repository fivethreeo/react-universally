- name: knoxauth
  actioncreators_prepend: |
    import { checkHttpStatus, parseJSON } from './components/utils'
    import {
      push, go, replace
    } from 'react-router-redux'

    import config from '../../config';

    const api_url = (process.env.BUILD_FLAG_IS_CLIENT === 'true') ? config('apiurl_frontend') : config('apiurl_backend');

  actions:
    - name: authLoginUserRequest
    - name: authLoginUser
      args: email,password,redirect = '/'
      thunk:
        args: axios,cookies
        thunk: |
          
          dispatch(authLoginUserRequest());

          return axios
            .request({
              url: `${api_url}v1/accounts/login/`,
              method: 'post',
              auth: {
                username: email,
                password: password
              }
          })
          .then(checkHttpStatus)
          .then((response) => {
              cookies.set('knoxToken', response.data.token)
              dispatch(authLoginUserSuccess(response.data.user));
              dispatch(push(redirect));
          })
          .then(() => true)
          .catch((error) => {
              if (error && typeof error.response !== 'undefined' && error.response.status === 401) {
                  // Invalid authentication credentials
                  return error.response.json().then((data) => {
                      dispatch(authLoginUserFailureReport(401, data.non_field_errors[0]));
                  });
              } else if (error && typeof error.response !== 'undefined' && error.response.status >= 500) {
                  // Server side error
                  dispatch(authLoginUserFailureReport(500, 'A server error occurred while sending your data!'));
              } else {
                  // Most likely connection issues
                  dispatch(authLoginUserFailureReport('Connection Error', 'An error occurred while sending your data!'));
              }

              return Promise.resolve(true); // TODO: we need a promise here because of the tests, find a better way
            })
    - name: authLogoutAndRedirect
      thunk:
        args: axios,cookie
        thunk: |
          return axios
            .get(`https://jsonplaceholder.typicode.com/Todos/${id}`)
            .then(({ data }) => { for (let todo in data) dispatch(addTodo(todo)) })
            .then(() => true);
    - name: authLoginUserSuccess
      args: payload
    - name: authLoginUserFailure
      args: status,statusText
    - name: authLoginUserFailureReport
      args: status,statusText
      thunk:
        args: cookies
        thunk: |
          cookies.remove('knoxToken')
          dispatch(authLoginUserFailure(status, statusText))
          return Promise.resolve(true);
    - name: authLogoutUser
    - name: authLogoutUserDo
      thunk:
        args: cookies
        thunk: |
          cookies.remove('knoxToken')
          dispatch(authLogout())
          return Promise.resolve(true)
    - name: authLogoutUserAndRedirect
      thunk:
        args: cookies
        thunk: |
          dispatch(authLogoutUserDo())
          dispatch(push('/login'))
          return Promise.resolve(true)

  reducers_prepend: |
    const initialState = {
        userName: null,
        isAuthenticated: false,
        isAuthenticating: false,
        statusText: null
    };
  reducers:
    - name: authReducer
      default: initialState
      actions:
        - name: authLoginUserRequest
          reducer: |
            return Object.assign({}, state, {
                isAuthenticating: true,
                statusText: null
            });
        - name: authLoginUserSuccess
          reducer: |
            return Object.assign({}, state, {
                isAuthenticating: false,
                isAuthenticated: true,
                userName: action.payload.email,
                statusText: 'You have been successfully logged in.'
            });

        - name: authLoginUserFailure
          reducer: |
            return Object.assign({}, state, {
                isAuthenticating: false,
                isAuthenticated: false,
                userName: null,
                statusText: `Authentication Error: ${action.payload.status} - ${action.payload.statusText}`
            });
        - name: authLogoutUser
          reducer: |
            return Object.assign({}, state, {
                isAuthenticated: false,
                userName: null,
                statusText: 'You have been successfully logged out.'
            });
  selectors:
  components:
    - name: utils
      component_content: |
        export function checkHttpStatus(response) {
            if (response.status >= 200 && response.status < 300) {
                return response;
            }

            const error = new Error(response.statusText);
            error.response = response;
            throw error;
        }

    - name: LoginRoute
      actions:
      selectors:
      prepend: |
        import React from 'react';
        import PropTypes, { string } from 'prop-types';
        import { compose } from 'redux';
        import { connect } from 'react-redux';
        import { withJob } from 'react-jobs';
        import Helmet from 'react-helmet';
        import LoginForm from './LoginForm';
      component_content: |

        class LoginRoute extends React.Component {

          render() {
            return (
              <div>
                <h3>Login</h3><LoginForm next="/counter" />
              </div>
            );
          }
        }

        // export default connect(mapStateToProps, mapActionsToProps)(LoginRoute);

        export default LoginRoute
    - name: LoginForm
      actions:
        authLoginUser: authLoginUser
      prepend: |
        import Formsy from 'formsy-react';
        import React from 'react';
        import { compose } from 'redux';
        import { connect } from 'react-redux';
        import MyInput from './MyInput';
        import { Form } from 'reactstrap';
      component_content: |

        const grid = {
          label_opts: {sm: 1},
          col_opts: {sm: 3}
        }

        class LoginForm extends React.Component {
          constructor(props) {
            super(props);
            this.disableButton = this.disableButton.bind(this);
            this.enableButton = this.enableButton.bind(this);
            this.submit = this.submit.bind(this);
            this.state = { canSubmit: false };
            this.authLoginUser = props.authLoginUser;
            this.next = props.next;
          }

          disableButton() {
            this.setState({ canSubmit: false });
          }

          enableButton() {
            this.setState({ canSubmit: true });
          }

          submit(model) {
            this.authLoginUser(model.email, model.password, this.next);
          }

          render() {
            return (
              <Form tag={Formsy} onValidSubmit={this.submit} onValid={this.enableButton} onInvalid={this.disableButton}>
                <MyInput type="text" name="email"
                  placeholder="email@example.com" label="Email"
                  validations="isEmail"
                  validationError="This is not a valid email"
                  required row {...grid}
                />
                <MyInput type="password" name="password"
                  placeholder="Password" label="Password"
                  validations="isAlphanumeric"
                  validationError="This is not a valid password"
                  required row {...grid}
                />
                <button type="submit" disabled={!this.state.canSubmit}>Submit</button>
              </Form>
            );
          }
        }
        export default LoginForm = compose(
          //connect(mapStateToProps, mapActionsToProps)
          connect(()=>({}), mapActionsToProps)
        )(LoginForm);

    - name: MyInput
      component_content: |
        import { withFormsy } from 'formsy-react';
        import React from 'react';
        import { FormGroup, Label, Input, FormText, FormFeedback, Col } from 'reactstrap';

        const col_wrap = (col_opts, input) => (
          <Col {...col_opts}>
            {input}
          </Col>
        )


        const ChildField = ({inputWidget, row, label, help, input_position=null, label_opts={}, col_opts=null, ...rest}) => (
          <FormGroup check={rest.check} row={row} disabled={rest.disabled} className={rest.className}>
            <Label key="label" for={"id_"+rest.name} {...label_opts}>
              {input_position=="left" ? inputWidget(rest) : ""}
              {label}
              {input_position=="right" ? inputWidget(rest) : ""}
            </Label>
            {!input_position ? (col_opts ? col_wrap(col_opts, inputWidget(rest)) : inputWidget(rest)) : ""}
            {rest.errorMessage && <FormFeedback>{rest.errorMessage}</FormFeedback>}
            {help && <FormText color="muted">{help}</FormText>}
          </FormGroup>
        )

        const GridCheckField = ({col_opts={sm:2}, label_opts={check:true}, ...rest}) => {
          return ChildField({col_opts, label_opts, ...rest})
        }
        
        const InputWidget = ({
            errorMessage,
            getErrorMessage,
            getErrorMessages,
            getValue,
            hasValue,
            isFormDisabled,
            isValid,
            isPristine,
            isFormSubmitted,
            isRequired,
            isValidValue,
            resetValue,
            setValidations,
            setValue,
            showRequired,
            showError,
            validations,
            validationError,
            validationErrors,
            ...input
          }) => (
          <Input key="input" id={"id_"+input.name} {...input} placeholder={input.placeholder} valid={errorMessage ? false: true}/>
        )

        class MyInput extends React.Component {
          constructor(props) {
            super(props);
            this.changeValue = this.changeValue.bind(this);
          }

          getWidgetValue(event) {
            return event.currentTarget.value;
          }

          changeValue(event) {
            // setValue() will set the value of the component, which in
            // turn will validate it and the rest of the form
            // Important: Don't skip this step. This pattern is required
            // for Formsy to work.
            this.props.setValue(this.getWidgetValue(event));
          }

          render() {
            // An error message is returned only if the component is invalid
            const errorMessage = this.props.getErrorMessage();
            
            const {required, ...rest} = this.props;

            return ChildField({inputWidget: InputWidget, onChange: this.changeValue, errorMessage: errorMessage, ...rest});

          }
        }

        export default withFormsy(MyInput);
